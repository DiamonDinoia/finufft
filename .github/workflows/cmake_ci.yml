name: cmake ci linux macos windows

on: [push, pull_request]

jobs:
  pip-requirements:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          cache: 'pip'
          python-version: '3.10'
      - name: Generate requirements.txt
        run: |
          pip install --upgrade pip
          pip install pip-tools
          pip-compile --all-build-deps python/finufft/pyproject.toml -o requirements.txt
          echo pytest >> requirements.txt
          sed -i -E 's/(==|>=|<=|>|<|~=|!=).*//' requirements.txt
          cat requirements.txt
      - name: Upload requirements.txt
        uses: actions/upload-artifact@v4
        with:
          name: requirements
          path: requirements.txt

  cache:
    strategy:
      matrix:
        os: [ubuntu-22.04, windows-2022]
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: create cache directory
        shell: bash
        run: mkdir -p "cpm"
      - name: Check if cache exists
        id: cache
        uses: actions/cache@v4
        with:
          key: cpm-cache-00-${{ runner.os == 'windows' && 'windows-' || '' }}${{ hashFiles('**/CMakeLists.txt', 'cmake/**') }}
          enableCrossOsArchive: true
          path: cpm
      - name: Setup Cpp (on cache miss)
        if: steps.cache.outputs.cache-hit != 'true'
        uses: aminya/setup-cpp@v1
        with:
          cmake: true
      - name: Download dependencies in cache (Linux)
        if: steps.cache.outputs.cache-hit != 'true' && runner.os == 'Linux'
        run: |
          cmake -S . -B ./build -DCPM_SOURCE_CACHE="cpm"
          rm -rf build
          cmake -S . -B ./build -DFINUFFT_USE_DUCC0=ON -DCPM_SOURCE_CACHE="cpm"
      - name: Download dependencies in cache (Windows)
        if: steps.cache.outputs.cache-hit != 'true' && runner.os != 'Linux'
        run: |
          cmake -S . -B build -DCPM_SOURCE_CACHE="cpm"
          rm build -r -force
          cmake -S . -B build -DFINUFFT_USE_DUCC0=ON -DCPM_SOURCE_CACHE="cpm"
      - name: Cache dependencies
        if: steps.cache.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          key: cpm-cache-00-${{ runner.os == 'windows' && 'windows-' || '' }}${{ hashFiles('**/CMakeLists.txt', 'cmake/**') }}
          enableCrossOsArchive: true
          path: cpm

  cmake-ci:
    runs-on: ${{ matrix.os }}
    needs: [cache, pip-requirements]
    env:
      # Global env to simplify commands:
      CMAKE_GENERATOR: Ninja
      CPM_SOURCE_CACHE: cpm
      CTEST_OUTPUT_ON_FAILURE: "1"
      # sccache GitHub Actions integration (incl. Windows)
      SCCACHE_GHA_ENABLED: "true"
      SCCACHE_GHA_VERSION: "0"
      # Always pass MACOSX_DEPLOYMENT_TARGET (ignored off macOS)
      MACOSX_DEPLOYMENT_TARGET: ${{ startsWith(matrix.os, 'macos-') && replace(matrix.os, 'macos-', '') || '' }}
      # Use sccache via environment (as requested)
      CMAKE_C_COMPILER_LAUNCHER: sccache
      CMAKE_CXX_COMPILER_LAUNCHER: sccache
      CMAKE_CUDA_COMPILER_LAUNCHER: sccache
      # Moved from script into global env (for reuse in commands below)
      CMAKE_COMMON: "-DFINUFFT_BUILD_TESTS=ON -DCMAKE_MSVC_DEBUG_INFORMATION_FORMAT=Embedded -DCMAKE_POLICY_DEFAULT_CMP0141=NEW"
      PIP_CMAKE_COMMON: "-C cmake.define.FINUFFT_BUILD_TESTS=ON -C cmake.define.CMAKE_MSVC_DEBUG_INFORMATION_FORMAT=Embedded -C cmake.define.CMAKE_POLICY_DEFAULT_CMP0141=NEW"
    strategy:
      fail-fast: false
      matrix:
        include:
          - { os: ubuntu-22.04, toolchain: gcc-10, c_compiler: gcc,   cxx_compiler: g++ }
          - { os: ubuntu-22.04, toolchain: gcc-11, c_compiler: gcc,   cxx_compiler: g++ }
          - { os: ubuntu-22.04, toolchain: gcc-12, c_compiler: gcc,   cxx_compiler: g++ }
          - { os: ubuntu-22.04, toolchain: gcc-13, c_compiler: gcc,   cxx_compiler: g++ }
          - { os: ubuntu-22.04, toolchain: clang-16, c_compiler: clang, cxx_compiler: clang++ }
          - { os: ubuntu-22.04, toolchain: clang-17, c_compiler: clang, cxx_compiler: clang++ }
          - { os: ubuntu-22.04, toolchain: clang-18, c_compiler: clang, cxx_compiler: clang++ }

          - { os: windows-2022, toolchain: msvc,     c_compiler: cl,    cxx_compiler: cl }
          - { os: windows-2022, toolchain: clang-19, c_compiler: clang, cxx_compiler: clang++ }

          - { os: macos-13,    toolchain: llvm,    c_compiler: clang, cxx_compiler: clang++ }
          - { os: macos-13,    toolchain: gcc-14,  c_compiler: gcc,   cxx_compiler: g++ }
          - { os: macos-14,    toolchain: llvm,    c_compiler: clang, cxx_compiler: clang++ }
          - { os: macos-14,    toolchain: gcc-14,  c_compiler: gcc,   cxx_compiler: g++ }
          - { os: macos-15,    toolchain: llvm,    c_compiler: clang, cxx_compiler: clang++ }
          - { os: macos-15,    toolchain: gcc-14,  c_compiler: gcc,   cxx_compiler: g++ }
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Restore Cache
        uses: actions/cache/restore@v4
        with:
          key: cpm-cache-00-${{ runner.os == 'windows' && 'windows-' || '' }}${{ hashFiles('**/CMakeLists.txt', 'cmake/**') }}
          enableCrossOsArchive: true
          path: cpm

      - name: Download requirements.txt
        uses: actions/download-artifact@v4
        with:
          name: requirements

      - name: Run sccache-cache
        uses: mozilla-actions/sccache-action@v0.0.9

      - name: Setup Cpp
        uses: aminya/setup-cpp@v1
        with:
          compiler: ${{ matrix.toolchain }}
          vcvarsall: ${{ contains(matrix.os, 'windows') }}
          cmake: true
          ninja: true
          vcpkg: false
          cppcheck: false
          clangtidy: false

      # macOS: install deps (no global LDFLAGS/CPPFLAGS so builds without OpenMP aren't polluted)
      - name: Install fftw + OpenMP (macOS)
        if: startsWith(matrix.os, 'macos-')
        run: |
          brew install fftw libomp
          # Avoid setting LDFLAGS/CPPFLAGS/DYLD_LIBRARY_PATH globally to not force OpenMP.
          # Allow CMake to find libomp only when OpenMP is requested.
          echo "CMAKE_PREFIX_PATH=$(brew --prefix):$(brew --prefix libomp)" >> $GITHUB_ENV
          echo "MACOSX_DEPLOYMENT_TARGET=${{ format('{0}.0', replace(matrix.os, 'macos-', '')) }}" >> $GITHUB_ENV

      - name: Install fftw (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt update
          sudo apt install -y libfftw3-dev

      - name: Select compilers (non-Windows)
        if: runner.os != 'Windows'
        run: |
          echo "CC=${{ matrix.c_compiler }}" >> $GITHUB_ENV
          echo "CXX=${{ matrix.cxx_compiler }}" >> $GITHUB_ENV

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'
          cache-dependency-path: requirements.txt

      - name: Install Python requirements
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip install -r requirements.txt

      - name: Build and test configurations
        shell: bash
        run: |
          set -euo pipefail

          # Build configs:
          # - Linux/macOS: DUCC0 {On,Off} × BuildType {Release,Debug}
          # - Windows:     DUCC0 {On} × BuildType {Release,Debug}
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            configs=("build_type=Release ducc_fft=On" "build_type=Debug ducc_fft=On")
          else
            configs=("build_type=Release ducc_fft=On" "build_type=Release ducc_fft=Off" \
                     "build_type=Debug ducc_fft=On"  "build_type=Debug ducc_fft=Off")
          fi

          # Architecture flags by toolchain/OS
          if [[ "${{ matrix.toolchain }}" == "msvc" ]]; then
            arch_flags=("/arch:AVX2" "/arch:SSE2" "native")
          elif [[ "$RUNNER_OS" == "Linux" ]]; then
            arch_flags=("-march=x86-64" "-march=x86-64-v2" "-march=x86-64-v3" "-march=native")
          else
            arch_flags=("native")
          fi

          for arch in "${arch_flags[@]}"; do
            arch_dir=$(echo "$arch" | tr -c 'A-Za-z0-9' '_')
            for cfg in "${configs[@]}"; do
              eval "$cfg"
              build_dir="build_${build_type}_${ducc_fft}_${arch_dir}"

              # Reuse the build directory to enable incremental configure/compile.
              # NOTE: Safe only if env vars that affect the build (compilers, PATH/SDK,
              # MACOSX_DEPLOYMENT_TARGET, flags injected via env) stay the same within
              # this loop iteration.
              cmake -E make_directory "$build_dir"

              cmake -S . -B "$build_dir" \
                -DCMAKE_BUILD_TYPE=$build_type \
                -DFINUFFT_ARCH_FLAGS=$arch \
                -DFINUFFT_USE_DUCC0=$ducc_fft \
                -DCMAKE_OSX_DEPLOYMENT_TARGET=${MACOSX_DEPLOYMENT_TARGET} \
                ${CMAKE_COMMON}

              cmake --build "$build_dir" --config "$build_type"
              (cd "$build_dir" && ctest -C "$build_type")

              # Build & test Python package with matching CMake options
              python3 -m pip install \
                --verbose \
                -C cmake.define.CMAKE_BUILD_TYPE=$build_type \
                -C cmake.define.FINUFFT_ARCH_FLAGS=$arch \
                -C cmake.define.FINUFFT_USE_DUCC0=$ducc_fft \
                -C cmake.define.CMAKE_OSX_DEPLOYMENT_TARGET=${MACOSX_DEPLOYMENT_TARGET} \
                ${PIP_CMAKE_COMMON} \
                python/finufft

              python3 -m pytest python/finufft/test
            done
          done

  cleanup:
    runs-on: ubuntu-22.04
    needs: cmake-ci
    steps:
      - name: Artifact cleanup
        uses: geekyeggo/delete-artifact@v5
        with:
          name: requirements
